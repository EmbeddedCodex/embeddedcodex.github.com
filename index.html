<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Title of the document</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>传输帧格式</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            border: 1px solid black;
            padding: 8px;
            text-align: center;
        }

        /* 经典黑白 */
        .black-white {
            background-color: #FFFFFF;
            /* 白色背景 */
            color: #000000;
            /* 黑色字体 */
        }

        .header,
        /* 深蓝与白 */
        .navy-white {
            background-color: #00008B;
            /* 深蓝色背景 */
            color: #FFFFFF;
            /* 白色字体 */
        }

        /* 海军蓝与黄 */
        .navy-yellow {
            background-color: #F8F8FF;
            /* Ghost White 背景 */
            color: #000080;
            /* 海军蓝字体 */
        }

        .cs,
        /* 森林绿与白 */
        .green-white {
            background-color: #228B22;
            /* 森林绿背景 */
            color: #FFFFFF;
            /* 白色字体 */
        }

        /* 灰色与深灰 */
        .gray-darkgray {
            background-color: #A9A9A9;
            /* 暗灰色背景 */
            color: #000000;
            /* 黑色字体 */
        }

        .data,
        /* 金色与黑 */
        .gold-black {
            background-color: #FFD700;
            /* 金色背景 */
            color: #000000;
            /* 黑色字体 */
        }

        .control,
        /* 珊瑚与白 */
        .coral-white {
            background-color: #FF7F50;
            /* 珊瑚色背景 */
            color: #FFFFFF;
            /* 白色字体 */
        }

        /* 青色与黑 */
        .result,
        .cyan-black {
            background-color: #00FFFF;
            /* 青色背景 */
            color: #000000;
            /* 黑色字体 */
        }

        /* 紫色与白 */
        .footer,
        .purple-white {
            background-color: #800080;
            /* 紫色背景 */
            color: #FFFFFF;
            /* 白色字体 */
        }

        /* 橄榄绿与白 */
        .length,
        .olive-white {
            background-color: #6B8E23;
            /* 橄榄绿背景 */
            color: #FFFFFF;
            /* 白色字体 */
        }
    </style>
</head>


<body>

    <h1>3762校验与解析</h1>
    <input type="text" id="hexInput_3762" placeholder="输入十六进制字符串" style="width: 92%;"
        value="68 2E 00 60 01 00 00 00 00 00 20 01 00 00 00 00 02 16 01 02 02 E8 02 00 83 08 07 10 68 20 01 00 00 00 00 68 11 04 33 33 33 33 D2 16 E5 16">
    <button onclick="parseHex_3762()">解析</button>
    <div class="result_3762" id="result_3762"></div>
    <br>

    <script>
        function parseHex_3762() {
            const input = document.getElementById('hexInput_3762').value;
            const resultDiv = document.getElementById('result_3762');

            if (!/^[0-9A-Fa-f ]+$/.test(input)) {
                resultDiv.innerHTML = "输入无效，请输入有效的十六进制字符串。";
                return;
            }
            // 68 2E 00 60 01 00 00 00 00 00 20 01 00 00 00 00 02 16 01 02 02 E8 02 00 83 08 07 10 68 20 01 00 00 00 00 68 11 04 33 33 33 33 D2 16 E5 16 

            let bytes = [];
            let hexArray = input.trim().split(' ');
            for (let hex of hexArray) {
                if (hex.length === 2) {
                    const byte = parseInt(hex, 16);
                    bytes.push(byte);
                } else {
                    resultDiv.innerHTML += `无效的十六进制数: ${hex}<br>`;
                    return;
                }
            }

            const frame_len = bytes[1] + bytes[2] * 16;

            let frame_cs = 0;
            for (let i = 3; i < frame_len - 2; i++) {
                frame_cs += bytes[i];
            }
            frame_cs &= 0xFF;

            // 清空之前的内容
            resultDiv.innerHTML = '';

            // 计算解析结果字符串

            // 创建一个空的段落元素，存储结果字符串
            let gelement = document.createElement('p');
            gelement.classList.add('result');
            gelement.innerHTML = '解析结果: ';
            resultDiv.appendChild(gelement);

            // 1. 起始
            {
                let element = document.createElement('p');
                element.classList.add('header');
                element.textContent = '起始：' + hexArray[0] + 'H';
                resultDiv.appendChild(element);

                const data = bytes.slice(0, 1).map(function (num) { return num.toString(16).padStart(2, '0').toUpperCase() }).join(' ');
                gelement.innerHTML += '<span class="header">' + data + '</span> ';
            }

            // 2. 长度 L
            {
                let element = document.createElement('p');
                element.classList.add('length');
                element.textContent = '长度：' + frame_len;
                resultDiv.appendChild(element);

                const data = bytes.slice(1, 3).map(function (num) { return num.toString(16).padStart(2, '0').toUpperCase() }).join(' ');
                gelement.innerHTML += '<span class="length">' + data + '</span> ';

                if (frame_len != bytes.length) {
                    element.textContent = '报文缺失：' + frame_len + ' vs ' + bytes.length;
                    resultDiv.appendChild(element);
                    return;
                }
            }

            // 3. 控制域 C
            const frame_C = bytes[3];
            {
                let element = document.createElement('p');
                element.classList.add('control');
                element.textContent = '控制域：' + frame_C.toString(16).padStart(2, '0').toUpperCase() + 'H';
                resultDiv.appendChild(element);

                const data = bytes.slice(3, 4).map(function (num) { return num.toString(16).padStart(2, '0').toUpperCase() }).join(' ');
                gelement.innerHTML += '<span class="control">' + data + '</span> ';

                // 创建表格元素
                let table = document.createElement('table');

                // 创建表头行
                let thead = document.createElement('thead');
                let headerRow = document.createElement('tr');
                let headers = ['D7', 'D6', 'D5', 'D4-D3', 'D2-D0'];
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // 创建第二行，用于显示参数名称
                let tbody = document.createElement('tbody');
                let paramRow = document.createElement('tr');
                let params = ['传输方向位 DIR', '启动标志位 PRM', '地址域标识 ADD', '协议版本号 VER', '保留'];
                params.forEach(paramText => {
                    const td = document.createElement('td');
                    td.textContent = paramText;
                    paramRow.appendChild(td);
                });
                tbody.appendChild(paramRow);

                // 创建第三行，用于解析参数
                let explanationRow = document.createElement('tr');
                let explanations = [];
                if (frame_C & 0x80) {
                    explanations.push('上行方向')
                } else {
                    explanations.push('下行方向')
                }
                if (frame_C & 0x40) {
                    explanations.push('来自启动站')
                } else {
                    explanations.push('来自从动站')
                }
                if (frame_C & 0x20) {
                    explanations.push('带地址域')
                } else {
                    explanations.push('不带地址域')
                }
                explanations.push(((frame_C >> 2) & 0b11).toString(16))
                explanations.push(((frame_C >> 0) & 0b11).toString(16))

                explanations.forEach(explanation => {
                    const td = document.createElement('td');
                    td.textContent = explanation;
                    explanationRow.appendChild(td);
                });
                tbody.appendChild(explanationRow);

                // 将表体添加到表格
                table.appendChild(tbody);

                // 将表格添加到容器中
                resultDiv.appendChild(table);
            }

            // 4. 用户数据
            {
                let user_data = bytes.slice(4, frame_len - 2);
                let element = document.createElement('p');
                element.classList.add('data');
                element.textContent = '用户数据：' + user_data.map(function (num) {
                    return num.toString(16).padStart(2, '0').toUpperCase();
                }).join(' ');
                resultDiv.appendChild(element);

                const data = bytes.slice(4, frame_len - 2).map(function (num) { return num.toString(16).padStart(2, '0').toUpperCase() }).join(' ');
                gelement.innerHTML += '<span class="data">' + data + '</span> ';

                // 创建表格元素
                let table = document.createElement('table');
                let tbody = document.createElement('tbody');

                // 地址域 A
                {
                    let paramRow = document.createElement('tr');
                    let explanations = ['地址域 A'];
                    if (frame_C & 0x20) {
                        const ASRC = user_data.slice(0, 0 + 6).map(function (num) {
                            return num.toString(16).padStart(2, '0').toUpperCase();
                        }).join(' ');
                        const ADST = user_data.slice(6, 6 + 6).map(function (num) {
                            return num.toString(16).padStart(2, '0').toUpperCase();
                        }).join(' ');

                        explanations.push(ASRC + ';\n' + ADST);
                        user_data = user_data.slice(6 * 2,);
                    } else {
                        explanations.push('不带地址域')
                    }
                    explanations.forEach(explanation => {
                        const td = document.createElement('td');
                        td.textContent = explanation;
                        paramRow.appendChild(td);
                    });
                    tbody.appendChild(paramRow);
                }

                // 应用功能码 AFN
                {
                    let paramRow = document.createElement('tr');
                    let explanations = ['应用功能码 AFN'];
                    {
                        const AFN = user_data[0].toString(16).padStart(2, '0').toUpperCase() + 'H';
                        explanations.push(AFN);
                        user_data = user_data.slice(1,);
                    }
                    explanations.forEach(explanation => {
                        const td = document.createElement('td');
                        td.textContent = explanation;
                        paramRow.appendChild(td);
                    });
                    tbody.appendChild(paramRow);
                }

                // 帧序列域 SEQ
                {
                    let paramRow = document.createElement('tr');
                    let explanations = ['帧序列域 SEQ'];
                    {
                        const SEQ = user_data[0].toString(16).padStart(2, '0').toUpperCase() + 'H(' + user_data[0].toString(10) + ')';
                        explanations.push(SEQ);
                        user_data = user_data.slice(1,);
                    }
                    explanations.forEach(explanation => {
                        const td = document.createElement('td');
                        td.textContent = explanation;
                        paramRow.appendChild(td);
                    });
                    tbody.appendChild(paramRow);
                }

                // 数据识别编码 DI
                {
                    let paramRow = document.createElement('tr');
                    let explanations = ['数据识别编码 DI'];
                    {
                        const DI = user_data.slice(0, 4).map(function (num) {
                            return num.toString(16).padStart(2, '0').toUpperCase();
                        }).join(' ');
                        explanations.push(DI);
                        user_data = user_data.slice(4,);
                    }
                    explanations.forEach(explanation => {
                        const td = document.createElement('td');
                        td.textContent = explanation;
                        paramRow.appendChild(td);
                    });
                    tbody.appendChild(paramRow);
                }

                // 数据识别内容
                {
                    let paramRow = document.createElement('tr');
                    let explanations = ['数据识别内容'];
                    {
                        if (user_data.length > 0) {
                            const BIN = user_data.map(function (num) {
                                return num.toString(16).padStart(2, '0').toUpperCase();
                            }).join(' ');
                            explanations.push(BIN);
                        } else {
                            explanations.push('无数据内容')
                        }
                    }
                    explanations.forEach(explanation => {
                        const td = document.createElement('td');
                        td.textContent = explanation;
                        paramRow.appendChild(td);
                    });
                    tbody.appendChild(paramRow);
                }

                // 将表体添加到表格
                table.appendChild(tbody);

                // 将表格添加到容器中
                resultDiv.appendChild(table);
            }

            // 5. 帧校验和
            {
                let element = document.createElement('p');
                element.classList.add('cs');
                element.textContent = '帧校验和：' + hexArray[frame_len - 2] + 'H';
                resultDiv.appendChild(element);

                const data = bytes.slice(frame_len - 2, frame_len - 2 + 1).map(function (num) { return num.toString(16).padStart(2, '0').toUpperCase() }).join(' ');
                gelement.innerHTML += '<span class="cs">' + data + '</span> ';

                if (bytes[frame_len - 2] != frame_cs) {
                    element.textContent = '帧校验和：' + '错误：' + hexArray[frame_len - 2] + 'H, ' + '正确：' + frame_cs.toString(16).padStart(2, '0').toUpperCase() + 'H';
                    resultDiv.appendChild(element);
                }
            }

            // 6. 结束
            {
                let element = document.createElement('p');
                element.classList.add('footer');
                element.textContent = '结束：' + hexArray[frame_len - 1] + 'H';
                resultDiv.appendChild(element);

                const data = bytes.slice(frame_len - 1, frame_len - 1 + 1).map(function (num) { return num.toString(16).padStart(2, '0').toUpperCase() }).join(' ');
                gelement.innerHTML += '<span class="footer">' + data + '</span> ';
            }
        }
    </script>

    <table>

        长度 L ：是指帧数据的总长度，由 2 字节组成，包括用户数据长度 L1 和 6 个字节的固定
        长度（起始字符、长度、控制域、校验和、结束字符）。<br><br>

        帧校验和 CS ：是控制域和用户数据区所有字节的八位位组算术和，不考虑溢出位。<br><br>


        <tr>
            <td>起始字符（68H）</td>
            <td rowspan="2">固定报文头</td>
        </tr>
        <tr>
            <td>长度L</td>
        </tr>
        <tr>
            <td>控制域C</td>
            <td>控制域</td>
        </tr>
        <tr>
            <td>用户数据</td>
            <td>用户数据区</td>
        </tr>
        <tr>
            <td>校验和 CS</td>
            <td>帧校验和</td>
        </tr>
        <tr>
            <td>结束字符（16H）</td>
            <td>固定报文尾</td>
        </tr>
    </table>
    <p style="text-align: center;">图 1 传输帧格式</p>


    <h1>645校验与解析</h1>
    <input type="text" id="hexInput_645" placeholder="输入十六进制字符串" style="width: 92%;"
        value="68 20 01 00 00 00 00 68 11 04 33 33 33 33 D2 16">
    <button onclick="parseHex1()">解析</button>
    <div class="result_645" id="result_645"></div>
    <br>

    <table>

        帧校验和：从第一个帧起始符开始到校验码之前的所有各字节的模 256 的和，即各字节二进制算术和，不计超过 256 的溢出值。 <br><br>

        <thread>
            <tr>
                <th>说明</th>
                <th>代码</th>
            </tr>
        </thread>
        <tbody>
            <tr>
                <td>帧起始符</td>
                <td>68H</td>
            </tr>
            <tr>
                <td rowspan="6">地址域</td>
                <td>A0</td>
            </tr>
            <tr>
                <td>A1</td>
            </tr>
            <tr>
                <td>A2</td>
            </tr>
            <tr>
                <td>A3</td>
            </tr>
            <tr>
                <td>A4</td>
            </tr>
            <tr>
                <td>A5</td>
            </tr>
            <tr>
                <td>帧起始符</td>
                <td>68H</td>
            </tr>
            <tr>
                <td>控制码</td>
                <td>C</td>
            </tr>
            <tr>
                <td>数据域长度</td>
                <td>L</td>
            </tr>
            <tr>
                <td>数据域</td>
                <td>DATA</td>
            </tr>
            <tr>
                <td>校验码</td>
                <td>CS</td>
            </tr>
            <tr>
                <td>结束符</td>
                <td>16H</td>
            </tr>
        </tbody>
    </table>
    <p style="text-align: center;">图 2 传输帧格式</p>



    <h1>698校验与解析</h1>
    <input type="text" id="hexInput_698" placeholder="输入十六进制字符串" style="width: 92%;" value="">
    <button onclick="parseHex1()">解析</button>
    <div class="result_698" id="result_698"></div>
    <br>

    <table>

        帧头校验 HCS ：为2字节，是对帧头部分不包含起始字符和HCS本身的所有字节的校验。

        <br><br>

        帧校验 FCS ：为2字节，是对整帧不包含起始字符、结束字符和FCS本身的所有字节的校验。

        <br><br>


        <tr>
            <td>起始字符（68H）</td>
            <td rowspan="5">帧头</td>
        </tr>
        <tr>
            <td>长度域 L</td>
        </tr>
        <tr>
            <td>控制域 C</td>
        </tr>
        <tr>
            <td>地址域 A</td>
        </tr>
        <tr>
            <td>帧头校验 HCS</td>
        </tr>
        <tr>
            <td>链路用户数据</td>
            <td>链路用户数据（应用层）</td>
        </tr>
        <tr>
            <td>帧校验 FCS</td>
            <td rowspan="2">帧尾</td>
        </tr>
        <tr>
            <td>结束字符（16H）</td>
        </tr>
    </table>
    <p style="text-align: center;">图 3 传输帧格式</p>

</body>

</html>